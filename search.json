[{"title":"线段树学习笔记","url":"/2024/11/20/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"线段树学习笔记对线段树的介绍\n线段树是一种树形数据结构，属于二叉树\n一棵线段树的每个结点都可以用区间来表示。线段树的叶结点表示的区间为或。\n线段树支持单点修改，区间修改，区间和/区间最值等的查询。\n对于线段树的区间修改一般采用延迟修改方式\n线段树的每一棵子树要么只有一个root，要么就是一棵满二叉树\n\n\n线段树的建树线段树的表示因为线段树是一棵二叉树，所以可以采用与二叉堆一致的表示法：\n编号为p的结点的\n1.左结点的编号为\n2.右结点的编号为。\n类似二叉堆，线段树是一个结构体数组。\nstruct SegmentTree{    int l,r;// 表示该结点代表的区间    int dat;//区间[l,r]的最大值    int add;//延迟修改标记}\n线段树的结点为了避免最最让人难受的RE，所以考虑一棵线段树的最大结点数。\n设现在需要表示区间，使得构造的线段树为一棵满二叉树。\n由线段树的性质得知，该二叉树有n个叶结点，则总结点数为＋，即。\n因为我的个人习惯，我一般会不处理一个数组的第一个元素，即下标为的元素。\n#include&lt;bits/stdc++.h&gt;using namespace std;struct SegmentTree{    int l,r;// 表示该结点代表的区间    int dat;//区间[l,r]的最大值    int add;//延迟修改标记} t[4*1000001];int va[114514];//区间是数组下标区间，这是线段树叶结点实际代表的值void bulid(int l,int r,int p)// 结点的数组下标为p，表示区间[l,r]{    t[p].l = l;//代表区间初始化    t[p].r = r;    if(l == r)//叶结点    {        t[p].dat = va[l];        return;// 如果你想RE，建议删去这行    }    int mid = (l + r) / 2;    bulid(l,mid,p*2);// 左子结点    bulid(mid+1,r,p*2+1);//右子结点    t[p].dat = max(t[p*2].dat,t[p*2+1].dat);//自下往上更新数据}int main(){    //略}\n线段树的区间修改&amp;延迟修改区间修改对于访问到的每一个结点，如果修改范围完全包括了它，那么直接修改+打延迟修改标记。否则：\n1.若修改范围与该结点的左结点有重合，则递归修改左结点\n2.若修改范围与该结点的右结点有重合，则递归修改右结点\ncode:\n#include&lt;bits/stdc++.h&gt;using namespace std;void change(int l,int r,int add,int p)//add 为区间修改所要加上的值{    if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)    {        t[p].add += add;        t[p].dat += add;        return ;    }    int mid = (t[p].l + t[p].r) / 2;    if(l &lt;= mid)    {        change(l,r,add,p*2);    }    if(mid &lt; r)    {        change(l,r,add,p*2+1);    }}\n延迟修改:延迟修改的含义并不是当访问到该结点时在进行修改，而是在访问到它时，它已经被修改，若其不是叶结点，则给它的两个子结点，进行对应修改并打上标记，代表该结点已被修改，但其子结点没有被修改。\ncode:\n#include&lt;bits/stdc++.h&gt;using namespace std;void spread(int p)// p为父结点下标{    if(t[p].add &amp;&amp; t[p].l != t[p].r)    {        t[p*2].add = t[p*2+1].add = t[p].add;//给子结点打标记        t[p*2].dat += t[p].add;        t[p*2+1].dat += t[p].add;//因为是最大值，所以直接加上就行        t[p].add = 0;//删除标记    }}int main(){    //略}\n线段树的区间查询对于访问到的每一个结点，如果查询范围完全包括了它，那么直接返回。否则：\n1.若查询范围与该结点的左结点有重合，则递归查询左结点\n2.若查询范围与该结点的右结点有重合，则递归查询右结点\ncode：:#include&lt;bits/stdc++.h&gt;using namespace std;typename ask(int l,int r,int p){    if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)    {        return t[p].dat;    }    int mid = (t[p].l + t[p].r) / 2;    if(l &lt;= mid)    {        ask(l,r,p*2);    }    if(mid &lt; r)    {        ask(l,r,p*2+1)    }}To be continued\n"},{"title":"单源最短路径 1. 狄克斯特拉(Dijkstra)算法","url":"/2025/03/06/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%201.%20%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89(Dijkstra)%E7%AE%97%E6%B3%95/","content":"狄克斯特拉(Dijkstra)算法单源最短路径问题给定一张有向图，是点集，是边集，，，节点以之间的连续整数编号,描述一条从出发，到达，权值为的有向边，求长度为的数组,其中表示从起点到节点的最短路径的长度。——选自李煜东《算法竞赛进阶指南》\n理论知识部分Dijkstra算法基于贪心思想：在寻找最短路时，先找每两个节点间的最短路，再依次扩大范围，直到求出数组。\n步骤1.初始化数组（0x3f3f3f3f），，数组初始化为2.找到值最小且未被访问过的节点，标记已访问3.扫描节点的每一条出边(终点用表示，权值用表示)，如果,则4.重复~步，直到所有节点都被访问过\n代码实现部分图的存储参见这篇博客\n算法主体步骤中值最小节点可以用STL priority_queue实现，因为它是大根堆，又要表现值最小和节点编号,两个信息，所以可以用它存储一个二元组，第一元为（实现小根堆），第二元为节点编号\n\nC++\n\npriority_queue &lt; pair&lt;int,int&gt; &gt; q;void dis(void){\tmemset(d,0x3f,sizeof(d));\td[s] = 0;\tq.push( make_pair(0,s) );\twhile(q.size())\t{\t\tint x = q.top().second;//获取节点编号\t\tq.pop();\t\tif(vis[x])//是否被访问\t\t\tcontinue;\t\tvis[x] = 1;//标记已访问\t\tfor(int i = head[x],y ;i ;i = Next[i])//步骤3\t\t{\t\t\ty = edge[i];\t\t\tif(d[y] &gt; d[x] + weight[i])\t\t\t{\t\t\t\td[y] = d[x] + weight[i];\t\t\t\tq.push( make_pair(-d[y],y) );//下一个节点\t\t\t}\t\t}\t}\tfor(int i = 1 ;i &lt;= n ;i++)            cout &lt;&lt; d[i] &lt;&lt; ' ';//输出结果}\n\n\n总结虽然本篇博客比较短，但该算法在图论中有重要地位，它也有着众多优化和变形。请读者思考本算法的各种实现细节。\n"},{"title":"链式前向星存图","url":"/2025/03/11/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE/","content":"链式前向星存图介绍图的存储方法很多，最常见的除邻接矩阵、邻接表和边集数组外，还有链式前向星。链式前向星是一种静态链表存储，用边集数组和邻接表相结合，可以快速访问一个节点的所有邻接点，在算法竞赛中广泛使用。在本质上，链式前向星其实也是数组模拟邻接表，所以我写这一篇博客是为了补充数组模拟邻接表的静态数组版本。\n理论知识部分存储链式前向星包括两个数组：边集和头结点1.边集中的每一个元素包含了为的边的终点、权值和与边起点相同的下一条边的(相当于邻接表中的数组)2.头结点中的每一个元素包含了以节点为起点的第一条边（相当于邻接表中的数组）\n代码实现部分存储实现\n数组\nC++\n\nstruct Edge{\tint edge;//边的终点\tint Next;//下一条边\tint weight;//权值}edge[N];\n\n\n加入边\nC++\n\nint cnt=0;//边数void add(int from, int to, int weight){\tedge[++cnt].to = y;//记录终点 注意用++cnt，而非cnt++\tedge[cnt].weight = weight;//权值\tedge[cnt].Next = head[from];\thead[from] = cnt;//更新链表}\n\n"},{"title":"数组模拟邻接表存图","url":"/2024/12/06/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%9B%BE/","content":"数组模拟邻接表存图邻接表的介绍\n邻接表是一个链表\n该链表的每一个节点都是一个单独的链表的head结点。\n邻接表的主要作用/最常见作用是存图，相较于邻接矩阵有较低的时间复杂度。\n\n因为本人是个蒟蒻，再加上用指针没人给你debug，所以就不放code了。\n数组模拟邻接表因为它的作用是存图，所以定义的变量名我就按存图代码来写了。\n为了节约空间，降低空间复杂度，避免MLE，所以我选择用STL容器vector（对于每个测试点数组大小不同，不用new运算符是为了防止RE）:vector&lt;int&gt; head,edge,Next,weihght,其中head[]数组表示结点的一条边，而这条边会通过节点编号(我用来表示),访问Next数组的下标为的元素,找到结点的下一条边(而这一条边会通过同样的方式访问到再下一条边,直到访问完结点的每一条边）。\n数组weight,它的下标为的元素表示的是边的权值。\n数组edge,它的下标为的元素表示的是边通向的点。\n代码实现部分初始化为了方便构建一张图，一般在main函数的开头利用vector类的resize()成员函数给edge，Next，head，weight数组申请需要的空间。\n特别地，对于head数组，其他数组的大小依边数而确定，而head数组的大小依点数而定。head数组中如果一个元素值为0，代表着编号为该元素的下标的点无以它为起点的边。\n遍历代码（dfs）我就不写了，只提供增加边函数和main函数片段\ncode：\n\n\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int id=0;//表示目前边数的值vector&lt;int&gt; edge,Next,head,weight;void add(int from,int to,int pay)//from为这条边的起点，to为终点，pay为权值{\tedge[++id] = to;//记录边的终点\tweight[id] = pay;//记录权值\tNext[id] = head[from];//插入结点,链表断开\thead[from] = id;//重新链接链表,结点已插入\tid++;//更新边数}int main(){\tint n,m;// n为点数，m为边数\tcin &gt;&gt; n &gt;&gt; m;\thead.resize(n+1)；\tedge.resize(m+1);\tNext.resize(m+1);\tweight.resize(m+1);\t//略}\n\n"},{"title":"LCA 最近公共祖先","url":"/2025/03/13/LCA%20%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","content":"LCA 最近公共祖先定义给定一颗有根数，若节点既是节点的祖先，也是节点的祖先，则称是和的公共祖先。在、的所有公共祖先中，深度最大的一个称为，的最近公共祖先，记为\n如上图中，,,# 算法求有三种算法：1. 向上标记法2. 树上倍增法3. Tarjan算法## 向上标记法从向上走到根节点，并标记所有经过的节点从向上走到根节点，当第一次遇到已标记的节点时，就找到了对于每个询问，向上标记法的时间复杂度最坏为，但该算法常数大，面对大量询问时易TLE，在算法竞赛中运用较少。## 树上倍增法### 节点表示祖先设为的距离为的祖先编号，如在上图中  ,特殊的，若  不存在，则令  ,例如 #### 深度令表示节点的深度### 求LCA求\n\n不妨设  (否则交换与)，\n寻找一个,使其满足  且最大。此时令  ,让不断向上走,直到  ，即与深度相等,进行第三步。\n如果  即是祖先，如上图中，此时便找到了\n寻找一个,使其满足  且最大。重复此步直到寻找不到这样的这一步在不断地将与向上走，保持深度一致，但不相遇（即不相等）,走到不能再向上走为止\n此时就是\n\nTarjan法留白\n"}]